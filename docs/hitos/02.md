# Hito 02: Persistencia, Multi-Tenancy y Módulo Documental

**Estado:** Planificado  
**Versión:** 1.0.0  
**Fecha de Creación:** 2025-12-29  
**Clasificación:** Especificación Técnica de Implementación

---

## 1. Objetivos del Hito

Este hito establece la capa de persistencia de datos con Prisma ORM, implementa la infraestructura de multi-tenancy como base arquitectónica del sistema, y desarrolla el primer módulo de dominio de negocio: el módulo documental para gestión de documentos y requisitos.

### 1.1 Entregables

- **Integración de Prisma ORM:** Configuración de Prisma Client con generación automática de tipos TypeScript
- **Sistema de Migraciones:** Migraciones versionadas con Prisma Migrate, scripts de rollback y seeders
- **Infraestructura Multi-Tenancy:** Modelo de datos con aislamiento por `tenant_id`, middleware de tenant context
- **Módulo Core - Tenants:** CRUD básico de tenants con configuración inicial
- **Módulo Core - Users:** Sincronización con Keycloak, perfiles de usuario con tenant association
- **Módulo Documental:** Gestión completa de organizaciones, personas, carpetas de documentos, requisitos y documentos
- **Integración S3:** Upload y download de documentos con presigned URLs
- **Audit Logging:** Registro de eventos críticos con tenant isolation

### 1.2 Fuera de Alcance (Hitos Futuros)

- Control de acceso basado en roles (RBAC) completo
- Módulos de access control físico, vehículos y casino
- Notificaciones de documentos próximos a vencer
- Workflow avanzado de aprobación de documentos
- Generación de certificados de acreditación

---

## 2. Principios Arquitectónicos

### 2.1 Multi-Tenancy como Base

**Estrategia:** Row-Level Security (RLS) mediante `tenant_id` en todas las entidades

**Principios:**

- **Aislamiento Total:** Cada query debe filtrar por `tenant_id`
- **Fail-Safe:** Queries sin tenant context deben fallar explícitamente
- **Performance:** Índices optimizados en columnas `tenant_id`
- **Auditoría:** Todos los eventos incluyen `tenant_id`

### 2.2 Repository Pattern con Tenant Awareness

**Patrón:** Todos los repositorios extienden de `TenantAwareRepository`

```typescript
abstract class TenantAwareRepository<T> {
	protected abstract model: string;

	constructor(protected prisma: PrismaService) {}

	protected getTenantFilter(tenantId: string) {
		return { tenantId };
	}

	async findMany(tenantId: string, where?: any) {
		return this.prisma[this.model].findMany({
			where: { ...this.getTenantFilter(tenantId), ...where },
		});
	}
}
```

### 2.3 Integración con S3 para Documentos

**Estrategia:** Presigned URLs para upload/download directo desde cliente

**Flujo de Upload:**

1. Cliente solicita URL de upload → Backend valida permisos
2. Backend genera presigned URL (15 min TTL) → Cliente recibe URL
3. Cliente sube archivo directamente a S3 → S3 confirma upload
4. Cliente notifica a backend → Backend crea registro en DB

---

## 3. Estructura del Proyecto

### 3.1 Nuevos Módulos

```
src/
├── infrastructure/
│   ├── database/
│   │   ├── prisma.service.ts          # Prisma client wrapper
│   │   ├── database.module.ts         # Global database module
│   │   └── repositories/
│   │       └── base-tenant-aware.repository.ts
│   └── storage/
│       ├── s3.service.ts               # S3 client wrapper
│       └── storage.module.ts
│
├── modules/
│   ├── tenants/                        # Módulo de tenants
│   │   ├── domain/
│   │   │   ├── tenant.entity.ts
│   │   │   └── tenant-settings.vo.ts
│   │   ├── application/
│   │   │   ├── ports/
│   │   │   │   └── tenant.repository.port.ts
│   │   │   └── use-cases/
│   │   │       ├── create-tenant.use-case.ts
│   │   │       ├── get-tenant.use-case.ts
│   │   │       └── update-tenant.use-case.ts
│   │   ├── infrastructure/
│   │   │   └── persistence/
│   │   │       └── prisma-tenant.repository.ts
│   │   └── interface/
│   │       ├── controllers/
│   │       │   └── tenants.controller.ts
│   │       └── dto/
│   │           ├── create-tenant.dto.ts
│   │           └── tenant-response.dto.ts
│   │
│   ├── users/                          # Módulo de usuarios
│   │   ├── domain/
│   │   │   └── user.entity.ts
│   │   ├── application/
│   │   │   ├── ports/
│   │   │   │   └── user.repository.port.ts
│   │   │   └── use-cases/
│   │   │       ├── sync-user-from-keycloak.use-case.ts
│   │   │       ├── get-user-profile.use-case.ts
│   │   │       └── update-user-profile.use-case.ts
│   │   ├── infrastructure/
│   │   │   └── persistence/
│   │   │       └── prisma-user.repository.ts
│   │   └── interface/
│   │       ├── controllers/
│   │       │   └── users.controller.ts
│   │       └── dto/
│   │           └── user-profile.dto.ts
│   │
│   └── documental/                     # Módulo documental
│       ├── domain/
│       │   ├── organization.entity.ts
│       │   ├── person.entity.ts
│       │   ├── document-folder.entity.ts
│       │   ├── document-requirement.entity.ts
│       │   └── document.entity.ts
│       ├── application/
│       │   ├── ports/
│       │   │   ├── organization.repository.port.ts
│       │   │   ├── person.repository.port.ts
│       │   │   ├── document-folder.repository.port.ts
│       │   │   └── document.repository.port.ts
│       │   └── use-cases/
│       │       ├── organizations/
│       │       │   ├── create-organization.use-case.ts
│       │       │   ├── list-organizations.use-case.ts
│       │       │   └── get-organization.use-case.ts
│       │       ├── persons/
│       │       │   ├── create-person.use-case.ts
│       │       │   ├── list-persons.use-case.ts
│       │       │   └── get-person.use-case.ts
│       │       ├── document-folders/
│       │       │   ├── create-document-folder.use-case.ts
│       │       │   └── list-document-folders.use-case.ts
│       │       └── documents/
│       │           ├── request-upload-url.use-case.ts
│       │           ├── confirm-document-upload.use-case.ts
│       │           ├── list-person-documents.use-case.ts
│       │           ├── get-document-download-url.use-case.ts
│       │           └── update-document-status.use-case.ts
│       ├── infrastructure/
│       │   └── persistence/
│       │       ├── prisma-organization.repository.ts
│       │       ├── prisma-person.repository.ts
│       │       ├── prisma-document-folder.repository.ts
│       │       └── prisma-document.repository.ts
│       └── interface/
│           ├── controllers/
│           │   ├── organizations.controller.ts
│           │   ├── persons.controller.ts
│           │   ├── document-folders.controller.ts
│           │   └── documents.controller.ts
│           └── dto/
│               ├── create-organization.dto.ts
│               ├── create-person.dto.ts
│               ├── create-document-folder.dto.ts
│               ├── upload-document-request.dto.ts
│               └── update-document-status.dto.ts
│
└── shared/
    ├── decorators/
    │   └── tenant-context.decorator.ts  # @TenantId() decorator
    └── middleware/
        └── tenant-context.middleware.ts  # Extract tenant from JWT
```

---

## 4. Schema de Base de Datos (Prisma)

### 4.1 Schema Completo

```prisma
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// CORE: Multi-Tenancy
// ============================================

model Tenant {
  id          String   @id @default(uuid())
  slug        String   @unique // URL-friendly identifier
  name        String
  description String?

  // Configuration
  settings    Json     @default("{}")
  isActive    Boolean  @default(true) @map("is_active")

  // Timestamps
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  users         User[]
  organizations Organization[]

  @@map("tenants")
}

// ============================================
// CORE: Users
// ============================================

model User {
  id              String   @id @default(uuid())
  tenantId        String   @map("tenant_id")

  // Keycloak sync
  keycloakId      String   @unique @map("keycloak_id")
  email           String
  emailVerified   Boolean  @default(false) @map("email_verified")

  // Profile
  firstName       String?  @map("first_name")
  lastName        String?  @map("last_name")
  phoneNumber     String?  @map("phone_number")

  // Status
  isActive        Boolean  @default(true) @map("is_active")

  // Timestamps
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  lastLoginAt     DateTime? @map("last_login_at")

  // Relations
  tenant                Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  reviewedDocuments     Document[] @relation("reviewer")
  auditLogsAsActor      AuditLog[] @relation("actor")

  @@unique([tenantId, email])
  @@index([tenantId])
  @@index([keycloakId])
  @@map("users")
}

// ============================================
// DOCUMENTAL: Organizations
// ============================================

model Organization {
  id          String   @id @default(uuid())
  tenantId    String   @map("tenant_id")

  // Basic info
  name        String
  taxId       String   @map("tax_id") // RUT/CUIT/Tax ID

  // Contact
  email       String?
  phoneNumber String?  @map("phone_number")
  address     String?

  // Status
  isActive    Boolean  @default(true) @map("is_active")

  // Timestamps
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  persons     Person[]

  @@unique([tenantId, taxId])
  @@index([tenantId])
  @@map("organizations")
}

// ============================================
// DOCUMENTAL: Persons
// ============================================

model Person {
  id              String   @id @default(uuid())
  tenantId        String   @map("tenant_id")
  organizationId  String   @map("organization_id")

  // Personal info
  firstName       String   @map("first_name")
  lastName        String   @map("last_name")
  idNumber        String   @map("id_number") // DNI/RUT/ID

  // Contact
  email           String?
  phoneNumber     String?  @map("phone_number")

  // Status
  isActive        Boolean  @default(true) @map("is_active")

  // Timestamps
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  documents       Document[]

  @@unique([tenantId, idNumber])
  @@index([tenantId])
  @@index([organizationId])
  @@map("persons")
}

// ============================================
// DOCUMENTAL: Document Folders
// ============================================

model DocumentFolder {
  id          String   @id @default(uuid())
  tenantId    String   @map("tenant_id")

  name        String
  description String?
  isActive    Boolean  @default(true) @map("is_active")

  // Timestamps
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  requirements DocumentRequirement[]

  @@index([tenantId])
  @@map("document_folders")
}

// ============================================
// DOCUMENTAL: Document Requirements
// ============================================

model DocumentRequirement {
  id          String   @id @default(uuid())
  tenantId    String   @map("tenant_id")
  folderId    String   @map("folder_id")

  name        String   // "Certificado médico", "Curso de altura"
  description String?
  isMandatory Boolean  @default(true) @map("is_mandatory")

  // Expiration settings
  hasExpiration      Boolean @default(false) @map("has_expiration")
  expirationMonths   Int?    @map("expiration_months")

  // Timestamps
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  folder      DocumentFolder @relation(fields: [folderId], references: [id], onDelete: Cascade)
  documents   Document[]

  @@index([tenantId])
  @@index([folderId])
  @@map("document_requirements")
}

// ============================================
// DOCUMENTAL: Documents
// ============================================

model Document {
  id              String   @id @default(uuid())
  tenantId        String   @map("tenant_id")
  personId        String   @map("person_id")
  requirementId   String   @map("requirement_id")

  // Storage
  fileName        String   @map("file_name")
  fileSize        Int      @map("file_size")
  mimeType        String   @map("mime_type")
  storageKey      String   @map("storage_key") // S3 key

  // Status
  status          DocumentStatus @default(PENDING)
  reviewedBy      String?  @map("reviewed_by")
  reviewedAt      DateTime? @map("reviewed_at")
  rejectionReason String?  @map("rejection_reason")

  // Expiration
  expiresAt       DateTime? @map("expires_at")

  // Timestamps
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  person          Person   @relation(fields: [personId], references: [id], onDelete: Cascade)
  requirement     DocumentRequirement @relation(fields: [requirementId], references: [id], onDelete: Cascade)
  reviewer        User?    @relation("reviewer", fields: [reviewedBy], references: [id])

  @@index([tenantId])
  @@index([personId])
  @@index([requirementId])
  @@index([status])
  @@map("documents")
}

enum DocumentStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

// ============================================
// AUDIT: Event Logging
// ============================================

model AuditLog {
  id            String   @id @default(uuid())
  tenantId      String   @map("tenant_id")

  // Event details
  action        String   // e.g., "DOCUMENT_UPLOADED", "DOCUMENT_APPROVED"
  entityType    String   @map("entity_type") // e.g., "Document", "Organization"
  entityId      String   @map("entity_id")

  // Actor
  actorId       String?  @map("actor_id")
  actorEmail    String?  @map("actor_email")

  // Context
  metadata      Json     @default("{}")
  ipAddress     String?  @map("ip_address")
  userAgent     String?  @map("user_agent")

  // Outcome
  outcome       AuditOutcome
  reasonCodes   String[] @map("reason_codes")

  // Timestamp
  timestamp     DateTime @default(now())

  // Relations
  actor         User?    @relation("actor", fields: [actorId], references: [id])

  @@index([tenantId, timestamp])
  @@index([entityType, entityId])
  @@index([actorId])
  @@map("audit_logs")
}

enum AuditOutcome {
  SUCCESS
  FAILURE
}
```

### 4.2 Migraciones

**Estructura de migraciones:**

```
prisma/
├── schema.prisma
├── migrations/
│   ├── 20250129000001_init_tenants_and_users/
│   │   └── migration.sql
│   ├── 20250129000002_init_documental_module/
│   │   └── migration.sql
│   └── 20250129000003_init_audit_logs/
│       └── migration.sql
└── seeds/
    ├── 01-default-tenant.seed.ts
    ├── 02-test-users.seed.ts
    └── 03-sample-document-folders.seed.ts
```

---

## 5. Detalles de Implementación

### 5.1 Prisma Service

```typescript
// src/infrastructure/database/prisma.service.ts

import {
	Injectable,
	OnModuleInit,
	OnModuleDestroy,
	Logger,
} from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService
	extends PrismaClient
	implements OnModuleInit, OnModuleDestroy
{
	private readonly logger = new Logger(PrismaService.name);

	constructor() {
		super({
			log: [
				{ emit: 'event', level: 'query' },
				{ emit: 'event', level: 'error' },
				{ emit: 'event', level: 'warn' },
			],
		});
	}

	async onModuleInit() {
		await this.$connect();
		this.logger.log('Database connection established');
	}

	async onModuleDestroy() {
		await this.$disconnect();
		this.logger.log('Database connection closed');
	}

	/**
	 * Enable soft delete middleware
	 */
	enableSoftDelete() {
		this.$use(async (params, next) => {
			if (params.action === 'delete') {
				params.action = 'update';
				params.args['data'] = { deletedAt: new Date() };
			}
			if (params.action === 'deleteMany') {
				params.action = 'updateMany';
				if (params.args.data !== undefined) {
					params.args.data['deletedAt'] = new Date();
				} else {
					params.args['data'] = { deletedAt: new Date() };
				}
			}
			return next(params);
		});
	}
}
```

### 5.2 Tenant Context Middleware

```typescript
// src/shared/middleware/tenant-context.middleware.ts

import {
	Injectable,
	NestMiddleware,
	UnauthorizedException,
} from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class TenantContextMiddleware implements NestMiddleware {
	use(req: Request, res: Response, next: NextFunction) {
		// Extract tenant from JWT claims (set by OidcAuthGuard)
		const tenantId = req.user?.tenantId;

		if (!tenantId) {
			throw new UnauthorizedException('Tenant context is required');
		}

		// Inject tenant into request
		req.tenantId = tenantId;
		next();
	}
}

// Extend Express Request type
declare global {
	namespace Express {
		interface Request {
			tenantId?: string;
		}
	}
}
```

### 5.3 Tenant Context Decorator

```typescript
// src/shared/decorators/tenant-context.decorator.ts

import { createParamDecorator, ExecutionContext } from '@nestjs/common';

/**
 * Extract tenant ID from request context
 * Usage: @TenantId() tenantId: string
 */
export const TenantId = createParamDecorator(
	(data: unknown, ctx: ExecutionContext): string => {
		const request = ctx.switchToHttp().getRequest();
		return request.tenantId;
	},
);
```

### 5.4 Base Tenant-Aware Repository

```typescript
// src/infrastructure/database/repositories/base-tenant-aware.repository.ts

import { PrismaService } from '../prisma.service';

export abstract class BaseTenantAwareRepository<T> {
	protected abstract readonly model: string;

	constructor(protected readonly prisma: PrismaService) {}

	protected getTenantFilter(tenantId: string) {
		return { tenantId };
	}

	async findMany(tenantId: string, where?: any, options?: any) {
		return this.prisma[this.model].findMany({
			where: {
				...this.getTenantFilter(tenantId),
				...where,
			},
			...options,
		});
	}

	async findUnique(tenantId: string, where: any) {
		return this.prisma[this.model].findFirst({
			where: {
				...this.getTenantFilter(tenantId),
				...where,
			},
		});
	}

	async create(tenantId: string, data: any) {
		return this.prisma[this.model].create({
			data: {
				...data,
				tenantId,
			},
		});
	}

	async update(tenantId: string, id: string, data: any) {
		return this.prisma[this.model].update({
			where: { id },
			data: {
				...data,
				// Verify tenant ownership
				tenant: {
					is: { id: tenantId },
				},
			},
		});
	}

	async delete(tenantId: string, id: string) {
		return this.prisma[this.model].delete({
			where: {
				id,
				tenantId,
			},
		});
	}
}
```

### 5.5 S3 Service para Upload de Documentos

```typescript
// src/infrastructure/storage/s3.service.ts

import { Injectable, Logger } from '@nestjs/common';
import {
	S3Client,
	PutObjectCommand,
	GetObjectCommand,
} from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { EnvService } from '@/config/env.service';

@Injectable()
export class S3Service {
	private readonly logger = new Logger(S3Service.name);
	private readonly s3Client: S3Client;
	private readonly bucketName: string;

	constructor(private readonly envService: EnvService) {
		this.s3Client = new S3Client({
			region: envService.s3Region,
			endpoint: envService.s3Endpoint,
			credentials: {
				accessKeyId: envService.s3AccessKeyId,
				secretAccessKey: envService.s3SecretAccessKey,
			},
		});
		this.bucketName = envService.s3BucketName;
	}

	/**
	 * Generate presigned URL for upload (15 minutes TTL)
	 */
	async getUploadUrl(key: string, contentType: string): Promise<string> {
		const command = new PutObjectCommand({
			Bucket: this.bucketName,
			Key: key,
			ContentType: contentType,
		});

		return getSignedUrl(this.s3Client, command, { expiresIn: 900 }); // 15 minutes
	}

	/**
	 * Generate presigned URL for download (1 hour TTL)
	 */
	async getDownloadUrl(key: string): Promise<string> {
		const command = new GetObjectCommand({
			Bucket: this.bucketName,
			Key: key,
		});

		return getSignedUrl(this.s3Client, command, { expiresIn: 3600 }); // 1 hour
	}

	/**
	 * Generate S3 key for document
	 * Format: {tenantId}/documents/{personId}/{documentId}/{filename}
	 */
	generateDocumentKey(
		tenantId: string,
		personId: string,
		documentId: string,
		filename: string,
	): string {
		return `${tenantId}/documents/${personId}/${documentId}/${filename}`;
	}
}
```

### 5.6 Ejemplo de Use Case: Upload Document

```typescript
// src/modules/documental/application/use-cases/documents/request-upload-url.use-case.ts

import {
	Injectable,
	NotFoundException,
	BadRequestException,
} from '@nestjs/common';
import { S3Service } from '@/infrastructure/storage/s3.service';
import { PersonRepositoryPort } from '../../ports/person.repository.port';
import { DocumentRequirementRepositoryPort } from '../../ports/document-requirement.repository.port';

interface RequestUploadUrlInput {
	tenantId: string;
	personId: string;
	requirementId: string;
	fileName: string;
	fileSize: number;
	mimeType: string;
}

interface RequestUploadUrlOutput {
	uploadUrl: string;
	documentId: string;
	storageKey: string;
}

@Injectable()
export class RequestUploadUrlUseCase {
	constructor(
		private readonly personRepository: PersonRepositoryPort,
		private readonly requirementRepository: DocumentRequirementRepositoryPort,
		private readonly s3Service: S3Service,
	) {}

	async execute(input: RequestUploadUrlInput): Promise<RequestUploadUrlOutput> {
		// Validate person exists and belongs to tenant
		const person = await this.personRepository.findById(
			input.tenantId,
			input.personId,
		);
		if (!person) {
			throw new NotFoundException('Person not found');
		}

		// Validate requirement exists and belongs to tenant
		const requirement = await this.requirementRepository.findById(
			input.tenantId,
			input.requirementId,
		);
		if (!requirement) {
			throw new NotFoundException('Document requirement not found');
		}

		// Validate file size (max 10MB)
		const maxSize = 10 * 1024 * 1024; // 10MB
		if (input.fileSize > maxSize) {
			throw new BadRequestException('File size exceeds maximum allowed (10MB)');
		}

		// Validate mime type
		const allowedTypes = ['application/pdf', 'image/jpeg', 'image/png'];
		if (!allowedTypes.includes(input.mimeType)) {
			throw new BadRequestException('File type not allowed');
		}

		// Generate document ID and storage key
		const documentId = crypto.randomUUID();
		const storageKey = this.s3Service.generateDocumentKey(
			input.tenantId,
			input.personId,
			documentId,
			input.fileName,
		);

		// Generate presigned upload URL
		const uploadUrl = await this.s3Service.getUploadUrl(
			storageKey,
			input.mimeType,
		);

		return {
			uploadUrl,
			documentId,
			storageKey,
		};
	}
}
```

---

## 6. API Endpoints

### 6.1 Tenants

```
POST   /tenants                    # Crear tenant (solo super-admin)
GET    /tenants                    # Listar tenants (solo super-admin)
GET    /tenants/:id                # Obtener tenant
PATCH  /tenants/:id                # Actualizar tenant
GET    /tenants/:id/settings       # Obtener configuración
PATCH  /tenants/:id/settings       # Actualizar configuración
```

### 6.2 Users

```
GET    /users/me                   # Perfil del usuario actual
PATCH  /users/me                   # Actualizar perfil
GET    /users                      # Listar usuarios del tenant
GET    /users/:id                  # Obtener usuario
```

### 6.3 Organizations

```
POST   /organizations              # Crear organización
GET    /organizations              # Listar organizaciones (paginado)
GET    /organizations/:id          # Obtener organización
PATCH  /organizations/:id          # Actualizar organización
DELETE /organizations/:id          # Eliminar organización
```

### 6.4 Persons

```
POST   /organizations/:orgId/persons    # Crear persona
GET    /organizations/:orgId/persons    # Listar personas de organización
GET    /persons/:id                     # Obtener persona
PATCH  /persons/:id                     # Actualizar persona
DELETE /persons/:id                     # Eliminar persona
```

### 6.5 Document Folders

```
POST   /document-folders           # Crear carpeta de documentos
GET    /document-folders           # Listar carpetas
GET    /document-folders/:id       # Obtener carpeta con requisitos
PATCH  /document-folders/:id       # Actualizar carpeta
POST   /document-folders/:id/requirements  # Agregar requisito
```

### 6.6 Documents

```
POST   /persons/:personId/documents/upload-request   # Solicitar URL de upload
POST   /persons/:personId/documents/confirm-upload   # Confirmar upload completado
GET    /persons/:personId/documents                  # Listar documentos de persona
GET    /documents/:id                                # Obtener documento
GET    /documents/:id/download                       # Obtener URL de descarga
PATCH  /documents/:id/status                         # Actualizar estado (aprobar/rechazar)
```

---

## 7. Testing

### 7.1 Database Testing Setup

```typescript
// test/setup-db.ts

import { PrismaClient } from '@prisma/client';
import { execSync } from 'child_process';

const prisma = new PrismaClient();

export async function setupTestDatabase() {
	// Push schema to test database
	execSync('npx prisma db push --skip-generate', {
		env: {
			...process.env,
			DATABASE_URL: process.env.DATABASE_URL_TEST,
		},
	});

	// Seed test data
	await seedTestData();
}

export async function teardownTestDatabase() {
	// Clean all tables
	const tables = await prisma.$queryRaw`
    SELECT tablename FROM pg_tables WHERE schemaname = 'public'
  `;

	for (const { tablename } of tables) {
		await prisma.$executeRawUnsafe(`TRUNCATE TABLE "${tablename}" CASCADE`);
	}

	await prisma.$disconnect();
}

async function seedTestData() {
	// Create test tenant
	const tenant = await prisma.tenant.create({
		data: {
			slug: 'test-tenant',
			name: 'Test Tenant',
			isActive: true,
		},
	});

	// Create test user
	await prisma.user.create({
		data: {
			tenantId: tenant.id,
			keycloakId: 'test-keycloak-id',
			email: 'test@example.com',
			firstName: 'Test',
			lastName: 'User',
		},
	});
}
```

### 7.2 Integration Tests

```typescript
// test/documental/organizations.e2e-spec.ts

import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '@/app.module';
import { setupTestDatabase, teardownTestDatabase } from '../setup-db';

describe('Organizations (e2e)', () => {
	let app: INestApplication;
	let authToken: string;
	let tenantId: string;

	beforeAll(async () => {
		await setupTestDatabase();

		const moduleFixture: TestingModule = await Test.createTestingModule({
			imports: [AppModule],
		}).compile();

		app = moduleFixture.createNestApplication();
		await app.init();

		// Get auth token and tenant ID
		// ... (mock or real Keycloak token)
	});

	afterAll(async () => {
		await teardownTestDatabase();
		await app.close();
	});

	describe('POST /organizations', () => {
		it('should create organization with valid data', () => {
			return request(app.getHttpServer())
				.post('/organizations')
				.set('Authorization', `Bearer ${authToken}`)
				.send({
					name: 'Test Organization',
					taxId: '12345678-9',
					email: 'contact@testorg.com',
				})
				.expect(201)
				.expect((res) => {
					expect(res.body).toHaveProperty('id');
					expect(res.body.name).toBe('Test Organization');
					expect(res.body.tenantId).toBe(tenantId);
				});
		});

		it('should reject duplicate taxId within tenant', async () => {
			// Create first organization
			await request(app.getHttpServer())
				.post('/organizations')
				.set('Authorization', `Bearer ${authToken}`)
				.send({
					name: 'Org 1',
					taxId: 'DUPLICATE-123',
				})
				.expect(201);

			// Try to create duplicate
			return request(app.getHttpServer())
				.post('/organizations')
				.set('Authorization', `Bearer ${authToken}`)
				.send({
					name: 'Org 2',
					taxId: 'DUPLICATE-123',
				})
				.expect(409); // Conflict
		});
	});

	describe('GET /organizations', () => {
		it('should list only organizations from user tenant', async () => {
			// Create organizations in test tenant
			await request(app.getHttpServer())
				.post('/organizations')
				.set('Authorization', `Bearer ${authToken}`)
				.send({ name: 'Org A', taxId: 'A-123' });

			await request(app.getHttpServer())
				.post('/organizations')
				.set('Authorization', `Bearer ${authToken}`)
				.send({ name: 'Org B', taxId: 'B-456' });

			// List organizations
			return request(app.getHttpServer())
				.get('/organizations')
				.set('Authorization', `Bearer ${authToken}`)
				.expect(200)
				.expect((res) => {
					expect(res.body.data).toHaveLength(2);
					expect(res.body.data.every((org) => org.tenantId === tenantId)).toBe(
						true,
					);
				});
		});
	});
});
```

---

## 8. Scripts NPM

```json
{
	"scripts": {
		"db:generate": "prisma generate",
		"db:migrate:dev": "prisma migrate dev",
		"db:migrate:deploy": "prisma migrate deploy",
		"db:migrate:reset": "prisma migrate reset",
		"db:seed": "ts-node prisma/seeds/index.ts",
		"db:studio": "prisma studio",
		"db:push": "prisma db push",
		"test:db:setup": "DATABASE_URL=$DATABASE_URL_TEST npm run db:push"
	}
}
```

---

## 9. Variables de Entorno Adicionales

```bash
# Database Configuration
DATABASE_URL=postgresql://user:pass@host.railway.app:5432/db?schema=public
DATABASE_URL_TEST=postgresql://user:pass@localhost:5432/test_db?schema=public

# Database Pool
DATABASE_POOL_MIN=2
DATABASE_POOL_MAX=10
DATABASE_CONNECTION_TIMEOUT=20000

# Prisma Configuration
PRISMA_LOG_LEVEL=info
PRISMA_QUERY_LOG=false

# S3 Storage (ya existentes, ahora se usan)
S3_ENDPOINT=https://railway.app
S3_BUCKET=eaa-documents-dev
S3_REGION=us-east-1
AWS_ACCESS_KEY_ID=AKIA...
AWS_SECRET_ACCESS_KEY=...

# Upload limits
MAX_FILE_SIZE_MB=10
ALLOWED_MIME_TYPES=application/pdf,image/jpeg,image/png

# Multi-Tenancy
DEFAULT_TENANT_ID=default-tenant-uuid
```

---

## 10. Criterios de Aceptación

### 10.1 Requisitos Funcionales

- ✅ Prisma Client genera tipos correctamente
- ✅ Migraciones se ejecutan sin errores en Railway
- ✅ Seeders crean tenant y usuario de prueba
- ✅ CRUD de tenants funcional (solo super-admin)
- ✅ CRUD de usuarios funcional con sincronización Keycloak
- ✅ CRUD de organizaciones con tenant isolation
- ✅ CRUD de personas asociadas a organizaciones
- ✅ CRUD de carpetas de documentos y requisitos
- ✅ Upload de documentos a S3 con presigned URLs
- ✅ Download de documentos con presigned URLs
- ✅ Cambio de estado de documentos (aprobar/rechazar)
- ✅ Audit logs se generan para operaciones críticas
- ✅ Tenant isolation verificado en todos los queries

### 10.2 Requisitos No Funcionales

- ✅ Queries de DB < 100ms (promedio)
- ✅ Connection pool configurado correctamente
- ✅ Cobertura de tests > 80%
- ✅ Documentación de schema actualizada
- ✅ Rollback de migraciones funcional
- ✅ Presigned URLs expiran correctamente
- ✅ Validación de tipos de archivo y tamaño

### 10.3 Requisitos de Seguridad

- ✅ Tenant isolation validado en todos los endpoints
- ✅ No hay SQL injection vulnerabilities
- ✅ Credenciales de DB en variables de entorno
- ✅ Audit logs inmutables (append-only)
- ✅ Presigned URLs con TTL corto
- ✅ Validación de permisos antes de generar URLs

---

## 11. Dependencias Nuevas

```json
{
	"dependencies": {
		"@prisma/client": "^5.8.0",
		"@aws-sdk/client-s3": "^3.478.0",
		"@aws-sdk/s3-request-presigner": "^3.478.0"
	},
	"devDependencies": {
		"prisma": "^5.8.0",
		"@types/node": "^20.10.0",
		"ts-node": "^10.9.2"
	}
}
```

---

## 12. Riesgos y Mitigaciones

| Riesgo                           | Probabilidad | Impacto | Mitigación                                                                 |
| -------------------------------- | ------------ | ------- | -------------------------------------------------------------------------- |
| Pérdida de datos en migración    | Media        | Alto    | Backup automático antes de cada migración, scripts de rollback testeados   |
| Performance con tenant isolation | Media        | Medio   | Índices optimizados en `tenant_id`, connection pooling, query optimization |
| Inconsistencia Keycloak-DB       | Baja         | Medio   | Sincronización idempotente, retry logic, reconciliation job                |
| Violación de tenant isolation    | Baja         | Crítico | Tests exhaustivos, middleware validation, code review obligatorio          |
| Problemas con S3 uploads         | Media        | Medio   | Retry logic, validación de upload completado, cleanup de uploads fallidos  |

---

## 13. Timeline Estimado

**Duración total:** 2-3 semanas

### Semana 1: Setup + Core Modules

- **Día 1:** Setup Prisma, schema inicial, primera migración
- **Día 2:** Módulo de tenants (CRUD básico)
- **Día 3:** Módulo de usuarios + sincronización Keycloak
- **Día 4:** Multi-tenancy middleware + decorators
- **Día 5:** Testing y ajustes de infraestructura

### Semana 2: Módulo Documental

- **Día 1:** Entidades Organization + Person
- **Día 2:** Entidades DocumentFolder + DocumentRequirement
- **Día 3:** Entidad Document + S3 integration
- **Día 4:** Use cases de upload/download
- **Día 5:** Use cases de review (aprobar/rechazar)

### Semana 3: Testing + Deploy

- **Día 1-2:** Integration tests completos
- **Día 3:** Audit logging implementation
- **Día 4:** Documentación y refinamiento
- **Día 5:** Deploy a Railway y validación

---

## 14. Documentación a Actualizar

1. **README.md**
   - Sección de database setup
   - Comandos de Prisma
   - Instrucciones de seeding

2. **AGENTS.md**
   - Patrones de repository con tenant awareness
   - Multi-tenancy guidelines
   - Audit logging standards

3. **DEVELOPMENT_INFRA.md**
   - Configuración de Prisma
   - Estrategia de migraciones
   - Backup y restore procedures

4. **Nuevo:** `docs/DATABASE.md`
   - Schema completo documentado
   - Relaciones entre entidades
   - Índices y optimizaciones
   - Estrategia de multi-tenancy

5. **Nuevo:** `docs/API.md`
   - Documentación de endpoints
   - Ejemplos de requests/responses
   - Códigos de error

---

## 15. Próximos Pasos (Hito 03)

Una vez completado el Hito 02, el sistema tendrá:

- ✅ Persistencia de datos funcional
- ✅ Multi-tenancy implementado
- ✅ Módulo documental completo
- ✅ Upload/download de documentos

**Hito 03 se enfocará en:**

1. **Workflow de Aprobación:** Estados avanzados, notificaciones
2. **Módulo de Access Control:** Evaluación de políticas, QR codes
3. **Dashboard:** Visualización de estado de documentos
4. **Notificaciones:** Email/SMS para documentos próximos a vencer

---

## 16. Referencias

- [Prisma Documentation](https://www.prisma.io/docs)
- [Multi-Tenancy Patterns](https://www.prisma.io/docs/guides/database/multi-tenancy)
- [AWS S3 Presigned URLs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/PresignedUrlUploadObject.html)
- [Repository Pattern](https://martinfowler.com/eaaCatalog/repository.html)
- [Domain-Driven Design](https://martinfowler.com/bliki/DomainDrivenDesign.html)

---

**Versión del Documento:** 1.0.0  
**Última Actualización:** 2025-12-29  
**Próxima Revisión:** Al completar Hito 02  
**Mantenido por:** Equipo de Desarrollo
